{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AutomationRegistryInterface1_2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @notice config of the registry\n * @dev only used in params and return values\n * @member paymentPremiumPPB payment premium rate oracles receive on top of\n * being reimbursed for gas, measured in parts per billion\n * @member flatFeeMicroLink flat fee paid to oracles for performing upkeeps,\n * priced in MicroLink; can be used in conjunction with or independently of\n * paymentPremiumPPB\n * @member blockCountPerTurn number of blocks each oracle has during their turn to\n * perform upkeep before it will be the next keeper's turn to submit\n * @member checkGasLimit gas limit when checking for upkeep\n * @member stalenessSeconds number of seconds that is allowed for feed data to\n * be stale before switching to the fallback pricing\n * @member gasCeilingMultiplier multiplier to apply to the fast gas feed price\n * when calculating the payment ceiling for keepers\n * @member minUpkeepSpend minimum LINK that an upkeep must spend before cancelling\n * @member maxPerformGas max executeGas allowed for an upkeep on this registry\n * @member fallbackGasPrice gas price used if the gas price feed is stale\n * @member fallbackLinkPrice LINK price used if the LINK price feed is stale\n * @member transcoder address of the transcoder contract\n * @member registrar address of the registrar contract\n */\nstruct Config {\n  uint32 paymentPremiumPPB;\n  uint32 flatFeeMicroLink; // min 0.000001 LINK, max 4294 LINK\n  uint24 blockCountPerTurn;\n  uint32 checkGasLimit;\n  uint24 stalenessSeconds;\n  uint16 gasCeilingMultiplier;\n  uint96 minUpkeepSpend;\n  uint32 maxPerformGas;\n  uint256 fallbackGasPrice;\n  uint256 fallbackLinkPrice;\n  address transcoder;\n  address registrar;\n}\n\n/**\n * @notice state of the registry\n * @dev only used in params and return values\n * @member nonce used for ID generation\n * @member ownerLinkBalance withdrawable balance of LINK by contract owner\n * @member expectedLinkBalance the expected balance of LINK of the registry\n * @member numUpkeeps total number of upkeeps on the registry\n */\nstruct State {\n  uint32 nonce;\n  uint96 ownerLinkBalance;\n  uint256 expectedLinkBalance;\n  uint256 numUpkeeps;\n}\n\ninterface AutomationRegistryBaseInterface {\n  function registerUpkeep(\n    address target,\n    uint32 gasLimit,\n    address admin,\n    bytes calldata checkData\n  ) external returns (uint256 id);\n\n  function performUpkeep(uint256 id, bytes calldata performData) external returns (bool success);\n\n  function cancelUpkeep(uint256 id) external;\n\n  function addFunds(uint256 id, uint96 amount) external;\n\n  function setUpkeepGasLimit(uint256 id, uint32 gasLimit) external;\n\n  function getUpkeep(uint256 id)\n    external\n    view\n    returns (\n      address target,\n      uint32 executeGas,\n      bytes memory checkData,\n      uint96 balance,\n      address lastKeeper,\n      address admin,\n      uint64 maxValidBlocknumber,\n      uint96 amountSpent\n    );\n\n  function getActiveUpkeepIDs(uint256 startIndex, uint256 maxCount) external view returns (uint256[] memory);\n\n  function getKeeperInfo(address query)\n    external\n    view\n    returns (\n      address payee,\n      bool active,\n      uint96 balance\n    );\n\n  function getState()\n    external\n    view\n    returns (\n      State memory,\n      Config memory,\n      address[] memory\n    );\n}\n\n/**\n * @dev The view methods are not actually marked as view in the implementation\n * but we want them to be easily queried off-chain. Solidity will not compile\n * if we actually inherit from this interface, so we document it here.\n */\ninterface AutomationRegistryInterface is AutomationRegistryBaseInterface {\n  function checkUpkeep(uint256 upkeepId, address from)\n    external\n    view\n    returns (\n      bytes memory performData,\n      uint256 maxLinkPayment,\n      uint256 gasLimit,\n      int256 gasWei,\n      int256 linkEth\n    );\n}\n\ninterface AutomationRegistryExecutableInterface is AutomationRegistryBaseInterface {\n  function checkUpkeep(uint256 upkeepId, address from)\n    external\n    returns (\n      bytes memory performData,\n      uint256 maxLinkPayment,\n      uint256 gasLimit,\n      uint256 adjustedGasWei,\n      uint256 linkEth\n    );\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * @notice This is a deprecated interface. Please use AutomationCompatibleInterface directly.\n */\npragma solidity ^0.8.0;\nimport {AutomationCompatibleInterface as KeeperCompatibleInterface} from \"./AutomationCompatibleInterface.sol\";\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/Campaign.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\";\r\nimport \"./UpkeepIDConsumer.sol\";\r\n\r\n// errors\r\nerror Campaign__NotInC_State();\r\nerror Campaign__NotCreator(address _address);\r\nerror Campaign__DonatorIsCreator(address _address);\r\nerror Campaign__PayoutFailed();\r\nerror Campaign__NoDonationsHere(address _donatorAddress);\r\nerror Campaign__RefundFailed();\r\nerror Campaign__UpkeepNotNeeded();\r\nerror Campaign__AlreadyExpired(address _campaignAddress);\r\nerror Campaign__NotRefundable(address _campaignAddress);\r\nerror Campaign__CampaignBankrupt(address _campaignAddress);\r\n\r\n\r\ncontract Campaign is KeeperCompatibleInterface{\r\n  using SafeMath for uint256;\r\n\r\n  // enums\r\n  enum C_State {\r\n    Fundraising,\r\n    Expired,\r\n    Canceled\r\n  }\r\n\r\n  // c_state variables\r\n  address payable immutable public i_creator;\r\n  string public s_title;\r\n  string public s_description;\r\n  string public s_category;\r\n  string public s_imageURI;\r\n  string public s_campaignURI;\r\n  string[] public s_tags;\r\n  uint256 public goalAmount;\r\n  uint256 public duration;\r\n  uint256 public currentBalance;\r\n  uint256 private immutable i_lastTimeStamp;\r\n  uint256 private immutable i_maxTimeStamp;\r\n  uint256 public deadline;\r\n  C_State public c_state = C_State.Fundraising; // default c_state\r\n  address private immutable i_linkTokenAddress;\r\n  address private immutable i_upkeepCreatorAddress;\r\n  uint256 private rId;\r\n\r\n  struct CampaignObject {\r\n    address i_creator;\r\n    string s_title;\r\n    string s_description;\r\n    string s_category;\r\n    string[] s_tags;\r\n    uint256 goalAmount;\r\n    uint256 duration;\r\n    uint256 currentBalance;\r\n    C_State currentC_State;\r\n    string s_imageURI;\r\n    string s_campaignURI;\r\n    uint256 i_deadline;\r\n  }\r\n\r\n  struct phyReward {\r\n    uint256 price;\r\n    string title;\r\n    string description;\r\n    string[] perks;\r\n    uint256 delDate;\r\n    uint256 quantity;\r\n    string[] shipsTo;\r\n  }\r\n\r\n  struct digReward {\r\n    uint256 price;\r\n    string title;\r\n    string description;\r\n    string[] perks;\r\n    uint256 delDate;\r\n    uint256 quantity;\r\n    bool infinite;\r\n  }\r\n\r\n  mapping (uint256 => phyReward) public phyRewards;\r\n  mapping (uint256 => digReward) public digRewards;\r\n  mapping (address => uint256[]) public donations;\r\n\r\n\r\n  // events\r\n  event FundingRecieved (\r\n    address indexed contributor,\r\n    uint256 amount,\r\n    uint256 currentBalance\r\n  );\r\n  event CreatorPaid(address creator, address campaignAddress);\r\n  event CampaignSuccessful(address campaignAddress);\r\n  event CampaignExpired(address campaignAddress);\r\n  event CampaignCanceled();\r\n\r\n\r\n  // modifiers\r\n  modifier isCreator() {\r\n    if(msg.sender != i_creator){revert Campaign__NotCreator(msg.sender);}\r\n    _;\r\n  }\r\n\r\n\r\n  constructor (\r\n    address _creator,\r\n    string memory _title,\r\n    string memory _description,\r\n    string memory _category,\r\n    string[] memory _tags,\r\n    uint256 _goalAmount,\r\n    uint256 _duration,\r\n    string memory _imageURI,\r\n    string memory _campaignURI,\r\n    address _linkTokenAddress,\r\n    address _upkeepCreatorAddress\r\n  ) {\r\n    i_creator = payable(_creator);\r\n    s_title = _title;\r\n    s_description = _description;\r\n    s_category = _category;\r\n    s_tags = _tags;\r\n    goalAmount = _goalAmount;\r\n    i_lastTimeStamp = block.timestamp;\r\n    i_maxTimeStamp = i_lastTimeStamp + 5184000; // 60days\r\n    if(_duration > (i_maxTimeStamp.sub(i_lastTimeStamp))){\r\n      duration = i_maxTimeStamp.sub(i_lastTimeStamp);\r\n    }else{\r\n      duration = _duration;\r\n    }\r\n    deadline = i_lastTimeStamp + duration;\r\n    s_imageURI = _imageURI;\r\n    s_campaignURI = _campaignURI;\r\n    currentBalance = 0;\r\n    i_linkTokenAddress = _linkTokenAddress;\r\n    i_upkeepCreatorAddress = _upkeepCreatorAddress;\r\n  }\r\n\r\n  function timeBox() public isCreator {\r\n    UpkeepIDConsumer newUpkeepCreator = UpkeepIDConsumer(i_upkeepCreatorAddress);\r\n    LinkTokenInterface token = LinkTokenInterface(i_linkTokenAddress);\r\n    if(token.balanceOf(i_upkeepCreatorAddress) <= 0){revert(\"no funds\");}\r\n    rId = newUpkeepCreator.registerAndPredictID(s_title, \"0x\", address(this), 500000, i_creator, \"0x\", 10000000000000000000, 0);\r\n  }\r\n\r\n  function donate() external payable {\r\n    if(c_state != C_State.Fundraising){revert Campaign__NotInC_State();}\r\n    if (msg.sender == i_creator){revert Campaign__DonatorIsCreator(msg.sender);}\r\n    donations[msg.sender].push(msg.value);\r\n    currentBalance = currentBalance.add(msg.value);\r\n    emit FundingRecieved(msg.sender, msg.value, currentBalance);\r\n  }\r\n\r\n  /**\r\n    @dev this is the function chainlink keepers calls\r\n    chekupkeep returns true to trigger the action after the interval has passed\r\n   */\r\n  function checkUpkeep(bytes memory /**checkData */) public view override\r\n  returns (bool upkeepNeeded, bytes memory /**performData */) \r\n  {\r\n    bool isOpen = c_state == C_State.Fundraising;\r\n    bool timePassed = ((block.timestamp - i_lastTimeStamp) > duration);\r\n    bool hasBalance = address(this).balance > 0;\r\n    upkeepNeeded = (timePassed && isOpen && hasBalance) ;\r\n    return (upkeepNeeded, \"0x0\");\r\n  }\r\n\r\n  function performUpkeep(bytes calldata /**performData */) external override {\r\n    (bool upkeepNeeded, ) = checkUpkeep(\"\");\r\n    if(!upkeepNeeded){revert Campaign__UpkeepNotNeeded();}\r\n    c_state = C_State.Expired;\r\n    emit CampaignExpired(address(this));\r\n    if(currentBalance >= goalAmount){\r\n      emit CampaignSuccessful(address(this));\r\n    }\r\n  }\r\n\r\n  function payout() public isCreator {\r\n    if(c_state != C_State.Expired){revert Campaign__NotInC_State();}\r\n    uint256 totalRaised = currentBalance;\r\n    currentBalance = 0;\r\n    (bool success, ) = i_creator.call{value: totalRaised}(\"\");\r\n    if(success){\r\n      emit CreatorPaid(i_creator, address(this));\r\n    }\r\n    else{revert Campaign__PayoutFailed();}\r\n  }\r\n\r\n  function refund(address _donator) public {\r\n    if(c_state == C_State.Expired){revert Campaign__AlreadyExpired(address(this));}\r\n    if(donations[_donator].length == 0 ){revert Campaign__NoDonationsHere(_donator);}\r\n    uint256 amountToRefund = calcFunderDonations(donations[_donator]);\r\n    delete(donations[_donator]);\r\n    if(currentBalance < amountToRefund){revert Campaign__CampaignBankrupt(address(this));}\r\n    currentBalance = currentBalance.sub(amountToRefund);\r\n    (bool success, ) = payable(_donator).call{value: amountToRefund}(\"\");\r\n    if(!success){revert Campaign__RefundFailed();}\r\n  }\r\n\r\n  function calcFunderDonations(uint256[] memory _funderArr) private pure returns(uint256 result){\r\n    for (uint256 i = 0; i < _funderArr.length; i++) {\r\n      result += _funderArr[i];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function makeDigitalReward (\r\n    uint256 _price, string memory _title, \r\n    string memory _description, \r\n    string[] memory _perks,\r\n    uint256 _quantity,\r\n    bool _infinite\r\n    ) public isCreator {\r\n    digRewards[_price] = digReward(_price, _title, _description, _perks, deadline, _quantity, _infinite);\r\n  }\r\n\r\n  function makePhysicalReward( \r\n    uint256 _price, string memory _title, \r\n    string memory _description, string[] memory _perks, \r\n    uint256 _deadline, uint256 _quantity, string[] memory _shipsTo\r\n    ) public isCreator {\r\n    phyRewards[_price] = phyReward(_price, _title, _description, _perks, _deadline, _quantity, _shipsTo);\r\n  }\r\n\r\n  function deleteReward(uint256 _priceID) public isCreator {\r\n    if(phyRewards[_priceID].price > 0){delete(phyRewards[_priceID]);}\r\n    if(digRewards[_priceID].price > 0){delete(digRewards[_priceID]);}\r\n  }\r\n\r\n  function endCampaign() public isCreator {\r\n    if(c_state == C_State.Expired){revert Campaign__AlreadyExpired(address(this));}\r\n    c_state = C_State.Canceled;\r\n    emit CampaignCanceled();\r\n  }\r\n\r\n  // update functions\r\n  function updateGoalAmount(uint256 _newGoalAmount) public isCreator {\r\n    goalAmount = _newGoalAmount;\r\n  }\r\n\r\n  function updateDuration(uint256 _additionalTime) public isCreator {\r\n    if((_additionalTime + duration) > (i_maxTimeStamp.sub(i_lastTimeStamp))){\r\n      duration = i_maxTimeStamp.sub(i_lastTimeStamp); // 60days\r\n    }\r\n    else{\r\n      duration += _additionalTime;\r\n    }\r\n  }\r\n\r\n  function updateCampaignURI(string memory _campaignURI) public isCreator {\r\n    s_campaignURI = _campaignURI;\r\n  }\r\n  \r\n\r\n  // getter functions\r\n  function getDonations(address _donator) public view returns(uint256[] memory) {\r\n    return donations[_donator];\r\n  }\r\n\r\n  function getCampaignDetails() public view returns(CampaignObject memory) {\r\n    return CampaignObject(\r\n      i_creator,\r\n      s_title,\r\n      s_description,\r\n      s_category,\r\n      s_tags,\r\n      goalAmount,\r\n      duration,\r\n      currentBalance,\r\n      c_state,\r\n      s_imageURI,\r\n      s_campaignURI,\r\n      i_lastTimeStamp\r\n    );\r\n  }\r\n}"
    },
    "contracts/CrowdFunder.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"./Campaign.sol\";\r\n\r\n// errors\r\nerror CrowdFunder__NotCreator(address _caller, address _campaignAddress);\r\nerror CrowdFunder__CampaignStillActive(address _campaignAddress);\r\nerror CrowdFunder__DonationFailed(address _campaignAddress);\r\nerror CrowdFunder__RefundFailed(address _campaignAddress);\r\nerror CrowdFunder__CampaignNotRefundable(address _campaignAddress);\r\n\r\ncontract CrowdFunder {\r\n  using SafeMath for uint256;\r\n\r\n  event UserAdded(\r\n    address indexed _address,\r\n    string _username,\r\n    string _twitter,\r\n    string _email,\r\n    string _location,\r\n    string _bio\r\n  );\r\n\r\n  event CampaignAdded(\r\n    address indexed _campaignAddress,\r\n    address indexed _creator\r\n  );\r\n\r\n  event CampaignFunded(\r\n    address indexed _funder,\r\n    address indexed _campaignAddress\r\n  );\r\n\r\n  event CampaignShrunk(\r\n    address indexed _withdrawer,\r\n    address indexed _campaignAddress\r\n  );\r\n\r\n  event CampaignRemoved(\r\n    address indexed _campaignAddress\r\n  );\r\n\r\n  event UserHomeAddrAdded(\r\n    address _userAddress,\r\n    string _homeAddr\r\n  );\r\n\r\n  uint256 public campaignCounter;\r\n  mapping (address => Campaign) campaigns;\r\n\r\n\r\n  modifier isCreator(address _campaignAddress) {\r\n    if(campaigns[_campaignAddress].i_creator() != msg.sender){\r\n      revert CrowdFunder__NotCreator(msg.sender, _campaignAddress);\r\n    }\r\n    _;\r\n  }\r\n\r\n  function addUser(\r\n    address _address, string memory _username, \r\n    string memory _twitter, string memory _email, \r\n    string memory _location, string memory _bio\r\n    ) public {\r\n    emit UserAdded(_address, _username, _twitter, _email, _location, _bio);\r\n  }\r\n\r\n  function addCampaign (\r\n    string memory _title, \r\n    string memory _description,\r\n    string memory _category,\r\n    string[] memory _tags, \r\n    uint256 _goalAmount,\r\n    uint256 _duration,\r\n    string memory _imageURI,\r\n    string memory _campaignURI,\r\n    address _linkTokenAddress,\r\n    address _upkeepCreatorAddress\r\n    ) external {\r\n    Campaign newCampaign = new Campaign(\r\n      payable(msg.sender), _title, \r\n      _description, _category, \r\n      _tags, _goalAmount, \r\n      _duration, _imageURI, _campaignURI, \r\n      _linkTokenAddress, _upkeepCreatorAddress\r\n    );\r\n    campaigns[address(newCampaign)] = newCampaign;\r\n    campaignCounter+=1;\r\n    emit CampaignAdded(address(newCampaign), msg.sender);\r\n  }\r\n\r\n  function donateToCampaign (address _campaignAddress) public payable {\r\n    (bool success, ) = _campaignAddress.delegatecall(abi.encodeWithSignature(\"donate()\"));\r\n    if(success){\r\n      emit CampaignFunded(msg.sender, _campaignAddress);\r\n    }else{\r\n      revert CrowdFunder__DonationFailed(_campaignAddress);\r\n    }\r\n  }\r\n\r\n  function refundFromCampaign(address _campaignAddress, address _donator) public {\r\n    (bool success,) = _campaignAddress.delegatecall(abi.encodeWithSignature(\"refund(address)\", _donator));\r\n    if(success){\r\n      emit CampaignShrunk(msg.sender, _campaignAddress);\r\n    }else{\r\n      revert CrowdFunder__RefundFailed(_campaignAddress);\r\n    }\r\n  }\r\n\r\n  function removeCampaign (address _campaignAddress) public isCreator(_campaignAddress) {\r\n    if(uint(campaigns[_campaignAddress].c_state()) == 0){revert CrowdFunder__CampaignStillActive(_campaignAddress);}\r\n    delete(campaigns[_campaignAddress]);\r\n    campaignCounter-=1;\r\n    emit CampaignRemoved(_campaignAddress);\r\n  }\r\n\r\n  function addUserHomeAddr (address _userAddress, string memory _homeAddr) public {\r\n    emit UserHomeAddrAdded(_userAddress, _homeAddr);\r\n  }\r\n}"
    },
    "contracts/UpkeepIDConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.8;\r\n\r\nimport {AutomationRegistryInterface, State, Config} from \"@chainlink/contracts/src/v0.8/interfaces/AutomationRegistryInterface1_2.sol\";\r\nimport {LinkTokenInterface} from \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\";\r\n\r\ninterface KeeperRegistrarInterface {\r\n  function register(\r\n    string memory name,\r\n    bytes calldata encryptedEmail,\r\n    address upkeepContract,\r\n    uint32 gasLimit,\r\n    address adminAddress,\r\n    bytes calldata checkData,\r\n    uint96 amount,\r\n    uint8 source,\r\n    address sender\r\n  ) external;\r\n}\r\n\r\ncontract UpkeepIDConsumer {\r\n  LinkTokenInterface public immutable i_link;\r\n  address public immutable registrar;\r\n  AutomationRegistryInterface public immutable i_registry;\r\n  bytes4 registerSig = KeeperRegistrarInterface.register.selector;\r\n\r\n  constructor(\r\n    address _link,\r\n    address _registrar,\r\n    address _registry\r\n  ) {\r\n    i_link = LinkTokenInterface(_link);\r\n    registrar = _registrar;\r\n    i_registry = AutomationRegistryInterface(_registry);\r\n  }\r\n\r\n  function registerAndPredictID(\r\n    string memory name,\r\n    bytes calldata encryptedEmail,\r\n    address upkeepContract,\r\n    uint32 gasLimit,\r\n    address adminAddress,\r\n    bytes calldata checkData,\r\n    uint96 amount,\r\n    uint8 source\r\n  ) public returns(uint){\r\n    (State memory state, Config memory _c, address[] memory _k) = i_registry.getState();\r\n    uint256 oldNonce = state.nonce;\r\n    bytes memory payload = abi.encode(\r\n      name,\r\n      encryptedEmail,\r\n      upkeepContract,\r\n      gasLimit,\r\n      adminAddress,\r\n      checkData,\r\n      amount,\r\n      source,\r\n      address(this)\r\n    );\r\n\r\n    i_link.transferAndCall(\r\n      registrar,\r\n      amount,\r\n      bytes.concat(registerSig, payload)\r\n    );\r\n    (state, _c, _k) = i_registry.getState();\r\n    uint256 newNonce = state.nonce;\r\n    if (newNonce == oldNonce + 1) {\r\n      uint256 upkeepID = uint256(\r\n        keccak256(\r\n          abi.encodePacked(\r\n            blockhash(block.number - 1),\r\n            address(i_registry),\r\n            uint32(oldNonce)\r\n          )\r\n        )\r\n      );\r\n      // DEV - Use the upkeepID however you see fit\r\n      return upkeepID;\r\n    } else {\r\n      revert(\"auto-approve disabled\");\r\n    }\r\n  }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}