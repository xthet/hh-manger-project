{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AutomationRegistryInterface2_0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @notice OnchainConfig of the registry\n * @dev only used in params and return values\n * @member paymentPremiumPPB payment premium rate oracles receive on top of\n * being reimbursed for gas, measured in parts per billion\n * @member flatFeeMicroLink flat fee paid to oracles for performing upkeeps,\n * priced in MicroLink; can be used in conjunction with or independently of\n * paymentPremiumPPB\n * @member checkGasLimit gas limit when checking for upkeep\n * @member stalenessSeconds number of seconds that is allowed for feed data to\n * be stale before switching to the fallback pricing\n * @member gasCeilingMultiplier multiplier to apply to the fast gas feed price\n * when calculating the payment ceiling for keepers\n * @member minUpkeepSpend minimum LINK that an upkeep must spend before cancelling\n * @member maxPerformGas max executeGas allowed for an upkeep on this registry\n * @member fallbackGasPrice gas price used if the gas price feed is stale\n * @member fallbackLinkPrice LINK price used if the LINK price feed is stale\n * @member transcoder address of the transcoder contract\n * @member registrar address of the registrar contract\n */\nstruct OnchainConfig {\n  uint32 paymentPremiumPPB;\n  uint32 flatFeeMicroLink; // min 0.000001 LINK, max 4294 LINK\n  uint32 checkGasLimit;\n  uint24 stalenessSeconds;\n  uint16 gasCeilingMultiplier;\n  uint96 minUpkeepSpend;\n  uint32 maxPerformGas;\n  uint32 maxCheckDataSize;\n  uint32 maxPerformDataSize;\n  uint256 fallbackGasPrice;\n  uint256 fallbackLinkPrice;\n  address transcoder;\n  address registrar;\n}\n\n/**\n * @notice state of the registry\n * @dev only used in params and return values\n * @member nonce used for ID generation\n * @member ownerLinkBalance withdrawable balance of LINK by contract owner\n * @member expectedLinkBalance the expected balance of LINK of the registry\n * @member totalPremium the total premium collected on registry so far\n * @member numUpkeeps total number of upkeeps on the registry\n * @member configCount ordinal number of current config, out of all configs applied to this contract so far\n * @member latestConfigBlockNumber last block at which this config was set\n * @member latestConfigDigest domain-separation tag for current config\n * @member latestEpoch for which a report was transmitted\n * @member paused freeze on execution scoped to the entire registry\n */\nstruct State {\n  uint32 nonce;\n  uint96 ownerLinkBalance;\n  uint256 expectedLinkBalance;\n  uint96 totalPremium;\n  uint256 numUpkeeps;\n  uint32 configCount;\n  uint32 latestConfigBlockNumber;\n  bytes32 latestConfigDigest;\n  uint32 latestEpoch;\n  bool paused;\n}\n\n/**\n * @notice all information about an upkeep\n * @dev only used in return values\n * @member target the contract which needs to be serviced\n * @member executeGas the gas limit of upkeep execution\n * @member checkData the checkData bytes for this upkeep\n * @member balance the balance of this upkeep\n * @member admin for this upkeep\n * @member maxValidBlocknumber until which block this upkeep is valid\n * @member lastPerformBlockNumber the last block number when this upkeep was performed\n * @member amountSpent the amount this upkeep has spent\n * @member paused if this upkeep has been paused\n * @member skipSigVerification skip signature verification in transmit for a low security low cost model\n */\nstruct UpkeepInfo {\n  address target;\n  uint32 executeGas;\n  bytes checkData;\n  uint96 balance;\n  address admin;\n  uint64 maxValidBlocknumber;\n  uint32 lastPerformBlockNumber;\n  uint96 amountSpent;\n  bool paused;\n  bytes offchainConfig;\n}\n\nenum UpkeepFailureReason {\n  NONE,\n  UPKEEP_CANCELLED,\n  UPKEEP_PAUSED,\n  TARGET_CHECK_REVERTED,\n  UPKEEP_NOT_NEEDED,\n  PERFORM_DATA_EXCEEDS_LIMIT,\n  INSUFFICIENT_BALANCE\n}\n\ninterface AutomationRegistryBaseInterface {\n  function registerUpkeep(\n    address target,\n    uint32 gasLimit,\n    address admin,\n    bytes calldata checkData,\n    bytes calldata offchainConfig\n  ) external returns (uint256 id);\n\n  function cancelUpkeep(uint256 id) external;\n\n  function pauseUpkeep(uint256 id) external;\n\n  function unpauseUpkeep(uint256 id) external;\n\n  function transferUpkeepAdmin(uint256 id, address proposed) external;\n\n  function acceptUpkeepAdmin(uint256 id) external;\n\n  function updateCheckData(uint256 id, bytes calldata newCheckData) external;\n\n  function addFunds(uint256 id, uint96 amount) external;\n\n  function setUpkeepGasLimit(uint256 id, uint32 gasLimit) external;\n\n  function setUpkeepOffchainConfig(uint256 id, bytes calldata config) external;\n\n  function getUpkeep(uint256 id) external view returns (UpkeepInfo memory upkeepInfo);\n\n  function getActiveUpkeepIDs(uint256 startIndex, uint256 maxCount) external view returns (uint256[] memory);\n\n  function getTransmitterInfo(address query)\n    external\n    view\n    returns (\n      bool active,\n      uint8 index,\n      uint96 balance,\n      uint96 lastCollected,\n      address payee\n    );\n\n  function getState()\n    external\n    view\n    returns (\n      State memory state,\n      OnchainConfig memory config,\n      address[] memory signers,\n      address[] memory transmitters,\n      uint8 f\n    );\n}\n\n/**\n * @dev The view methods are not actually marked as view in the implementation\n * but we want them to be easily queried off-chain. Solidity will not compile\n * if we actually inherit from this interface, so we document it here.\n */\ninterface AutomationRegistryInterface is AutomationRegistryBaseInterface {\n  function checkUpkeep(uint256 upkeepId)\n    external\n    view\n    returns (\n      bool upkeepNeeded,\n      bytes memory performData,\n      UpkeepFailureReason upkeepFailureReason,\n      uint256 gasUsed,\n      uint256 fastGasWei,\n      uint256 linkNative\n    );\n}\n\ninterface AutomationRegistryExecutableInterface is AutomationRegistryBaseInterface {\n  function checkUpkeep(uint256 upkeepId)\n    external\n    returns (\n      bool upkeepNeeded,\n      bytes memory performData,\n      UpkeepFailureReason upkeepFailureReason,\n      uint256 gasUsed,\n      uint256 fastGasWei,\n      uint256 linkNative\n    );\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * @notice This is a deprecated interface. Please use AutomationCompatibleInterface directly.\n */\npragma solidity ^0.8.0;\nimport {AutomationCompatibleInterface as KeeperCompatibleInterface} from \"./AutomationCompatibleInterface.sol\";\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/Campaign.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\";\r\nimport { UpkeepIDConsumer } from \"./UpkeepIDConsumer.sol\";\r\nimport { LinkTokenInterface } from \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\";\r\n\r\n// errors\r\nerror Cmp_NIS(); /**not in state */\r\nerror Cmp_NotCrtr();\r\nerror Cmp_DIC(); /**donator is creator */\r\nerror Cmp_NoDns();\r\nerror Cmp_RefF();\r\nerror Cmp_UpkNN();\r\nerror Cmp_NotRef();\r\nerror Cmp_Bankrupt();\r\n\r\ncontract Campaign is KeeperCompatibleInterface, ReentrancyGuard{\r\n  using SafeMath for uint256;\r\n\r\n  // enums\r\n  enum C_State {\r\n    Fundraising,\r\n    Expired,\r\n    Canceled\r\n  }\r\n\r\n  enum C_Mode {\r\n    Draft,\r\n    Published\r\n  }\r\n\r\n  // c_state variables\r\n  address payable immutable public i_creator;\r\n  string public s_title;\r\n  string public s_description;\r\n  string public s_category;\r\n  string public s_imageURI;\r\n  string public s_campaignURI;\r\n  string public s_tags;\r\n  uint256 public goalAmount;\r\n  uint256 public duration;\r\n  uint256 public currentBalance;\r\n  uint256 private immutable i_initTimeStamp;\r\n  uint256 private constant i_maxDur = 5184000;\r\n  uint256 public deadline;\r\n  C_Mode public c_mode = C_Mode.Draft;\r\n  C_State public c_state = C_State.Fundraising; // default c_state\r\n  uint256 private rId;\r\n\r\n  struct CampaignObject {\r\n    address i_creator;\r\n    string s_title;\r\n    string s_description;\r\n    string s_category;\r\n    string s_tags;\r\n    uint256 goalAmount;\r\n    uint256 duration;\r\n    uint256 currentBalance;\r\n    C_State currentC_State;\r\n    string s_imageURI;\r\n    string s_campaignURI;\r\n    uint256 deadline;\r\n  }\r\n\r\n  struct reward {\r\n    uint256 price;\r\n    string title;\r\n    string description;\r\n    string[] perks;\r\n    uint256 delDate;\r\n    uint256 quantity;\r\n    bool infinite;\r\n    string[] shipsTo;\r\n  }\r\n\r\n  mapping (uint256 => reward) public rewards;\r\n  mapping (address => uint256[]) public donations;\r\n  mapping (address => uint256) public aggrDonations;\r\n\r\n  uint256[] public rKeys;\r\n\r\n\r\n  // events\r\n  event FundingRecieved (\r\n    address indexed contributor,\r\n    uint256 amount,\r\n    uint256 currentBalance\r\n  );\r\n  event CreatorPaid(address creator, address campaignAddress);\r\n  event CampaignSuccessful(address campaignAddress);\r\n  event CampaignExpired(address campaignAddress);\r\n  event CampaignCanceled();\r\n\r\n\r\n  // modifiers\r\n  modifier isCreator() {\r\n    if(msg.sender != i_creator){revert Cmp_NotCrtr();}\r\n    _;\r\n  }\r\n\r\n\r\n  constructor (\r\n    address _creator,\r\n    string memory _title,\r\n    string memory _description,\r\n    string memory _category,\r\n    string memory _tags,\r\n    uint256 _goalAmount,\r\n    uint256 _duration,\r\n    string memory _imageURI\r\n  ) {\r\n    i_creator = payable(_creator);\r\n    s_title = _title;\r\n    s_description = _description;\r\n    s_category = _category;\r\n    s_tags = _tags;\r\n    goalAmount = _goalAmount;\r\n    i_initTimeStamp = block.timestamp;\r\n    duration = _duration > i_maxDur ? i_maxDur : _duration;\r\n    deadline = i_initTimeStamp.add(duration);\r\n    s_imageURI = _imageURI;\r\n    currentBalance = 0;\r\n  }\r\n\r\n  function timeBox(address _upkeepCreatorAddress, address _linkTokenAddress, address _campaignAddress) external isCreator {\r\n    UpkeepIDConsumer newUpkeepCreator = UpkeepIDConsumer(_upkeepCreatorAddress);\r\n    LinkTokenInterface token = LinkTokenInterface(_linkTokenAddress);\r\n    if(token.balanceOf(_upkeepCreatorAddress) == 0){revert(\"no funds\");}\r\n    rId = newUpkeepCreator.registerAndPredictID(s_title, \"0x\", _campaignAddress, 500000, i_creator, \"0x\", \"0x\", 2000000000000000000);\r\n    c_mode = C_Mode.Published;\r\n  }\r\n\r\n  function donate() public payable nonReentrant{\r\n    if(c_state != C_State.Fundraising){revert Cmp_NIS();}\r\n    if(msg.sender == i_creator){revert Cmp_DIC();}\r\n    currentBalance = currentBalance.add(msg.value);\r\n    if(rewards[msg.value].price > 0 && !rewards[msg.value].infinite) //exists and is not infinite\r\n    {\r\n      rewards[msg.value].quantity.sub(1);\r\n      if(rewards[msg.value].quantity == 0){delete(rewards[msg.value]);}\r\n    }\r\n    donations[msg.sender].push(msg.value);\r\n    aggrDonations[msg.sender].add(msg.value);\r\n    emit FundingRecieved(msg.sender, msg.value, currentBalance);\r\n  }\r\n\r\n  /**\r\n    @dev this is the function chainlink keepers calls\r\n    chekupkeep returns true to trigger the action after the interval has passed\r\n   */\r\n  function checkUpkeep(bytes memory /**checkData */) public view override\r\n  returns (bool upkeepNeeded, bytes memory /**performData */) \r\n  {\r\n    bool isOpen = c_state == C_State.Fundraising;\r\n    bool timePassed = ((block.timestamp.sub(i_initTimeStamp)) > duration);\r\n    bool hasBalance = address(this).balance > 0;\r\n    upkeepNeeded = (timePassed && isOpen && hasBalance) ;\r\n    return (upkeepNeeded, \"0x0\");\r\n  }\r\n\r\n  function performUpkeep(bytes calldata /**performData */) external override {\r\n    (bool upkeepNeeded, ) = checkUpkeep(\"\");\r\n    if(!upkeepNeeded){revert Cmp_UpkNN();}\r\n    c_state = C_State.Expired;\r\n    emit CampaignExpired(address(this));\r\n    if(currentBalance >= goalAmount){\r\n      emit CampaignSuccessful(address(this));\r\n    }\r\n  }\r\n\r\n  function payout() external isCreator{\r\n    if(c_state != C_State.Expired){revert Cmp_NIS();}\r\n    uint256 totalRaised = currentBalance;\r\n    currentBalance = 0;\r\n    (bool success, ) = i_creator.call{value: totalRaised}(\"\");\r\n    if(success){\r\n      emit CreatorPaid(i_creator, address(this));\r\n    }\r\n    else{revert();}\r\n  }\r\n\r\n  function refund(address _donator) external nonReentrant{\r\n    if(c_state == C_State.Expired){revert Cmp_NIS();}\r\n    if(aggrDonations[_donator] == 0 ){revert Cmp_NoDns();}\r\n    uint256 amountToRefund = aggrDonations[_donator];\r\n    delete(donations[_donator]);\r\n    delete(aggrDonations[_donator]);\r\n    if(currentBalance < amountToRefund){revert Cmp_Bankrupt();}\r\n    currentBalance = currentBalance.sub(amountToRefund);\r\n    (bool success, ) = payable(_donator).call{value: amountToRefund}(\"\");\r\n    if(!success){revert Cmp_RefF();}\r\n  }\r\n\r\n  function makeReward( \r\n    uint256 _price, string memory _title, \r\n    string memory _description, string[] memory _perks, \r\n    uint256 _deadline, uint256 _quantity, bool _infinite, string[] memory _shipsTo\r\n    ) external isCreator {\r\n    rKeys.push(_price);\r\n    // shipsto _NW, infinite true, quantitymax 100  (for digRewards)  shipsto _AITW for phyRewards\r\n    rewards[_price] = reward(_price, _title, _description, _perks, _deadline, _quantity, _infinite, _shipsTo);\r\n  }\r\n\r\n  function deleteReward(uint256 _priceID) external isCreator {\r\n    if(c_mode != C_Mode.Draft){revert();}\r\n    if(rewards[_priceID].price > 0){delete(rewards[_priceID]);}\r\n  }\r\n\r\n  function endCampaign() external isCreator {\r\n    if(c_state == C_State.Expired){revert();}\r\n    c_state = C_State.Canceled;\r\n    emit CampaignCanceled();\r\n  }\r\n\r\n  // update functions\r\n  function updateCampaignURI(string memory _campaignURI) external isCreator {\r\n    s_campaignURI = _campaignURI;\r\n  }\r\n\r\n  function updateDur(uint256 _addedDur) external isCreator {\r\n    duration = ((duration.add(_addedDur)) > i_maxDur) ? i_maxDur : duration.add(_addedDur);\r\n    deadline = i_initTimeStamp.add(duration);\r\n  }\r\n\r\n  // getter functions\r\n  function getDonations(address _donator) external view returns(uint256[] memory) {\r\n    return donations[_donator];\r\n  }\r\n\r\n  function getRewardKeys() external view returns(uint256[] memory){\r\n    return rKeys;\r\n  }\r\n  \r\n  function getReward(uint256 _priceID) external view returns (reward memory) {\r\n    return rewards[_priceID];\r\n  }\r\n\r\n  function getCampaignDetails() external view returns(CampaignObject memory) {\r\n    return CampaignObject(\r\n      i_creator,\r\n      s_title,\r\n      s_description,\r\n      s_category,\r\n      s_tags,\r\n      goalAmount,\r\n      duration,\r\n      currentBalance,\r\n      c_state,\r\n      s_imageURI,\r\n      s_campaignURI,\r\n      deadline\r\n    );\r\n  }\r\n\r\n  // fallback functions\r\n  fallback() external payable {\r\n    donate();\r\n  }\r\n  receive() external payable {\r\n    donate();\r\n  }\r\n}"
    },
    "contracts/CrowdFunder.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"./Campaign.sol\";\r\n\r\n// errors\r\nerror Crf_NotCrtr();\r\nerror Crf_CSA(); /** cmp still active */\r\nerror Crf_DonF();\r\nerror Crf_RefF();\r\nerror Crf_PubF();\r\n\r\ncontract CrowdFunder {\r\n  using SafeMath for uint256;\r\n\r\n  event UserAdded(\r\n    address indexed _address,\r\n    string _username,\r\n    string _twitter,\r\n    string _email,\r\n    string _homeAddress\r\n  );\r\n\r\n  event CampaignAdded(\r\n    address indexed _campaignAddress,\r\n    address indexed _creator,\r\n    string _title,\r\n    string _description,\r\n    string _category,\r\n    string _tags\r\n  );\r\n\r\n  event CampaignFunded(\r\n    address indexed _funder,\r\n    address indexed _campaignAddress\r\n  );\r\n\r\n  event CampaignShrunk(\r\n    address indexed _withdrawer,\r\n    address indexed _campaignAddress\r\n  );\r\n\r\n  event CampaignRemoved(\r\n    address indexed _campaignAddress\r\n  );\r\n\r\n  event CampaignPublished(\r\n    address _campaignAddress\r\n  );\r\n\r\n  uint256 public campaignCounter;\r\n  mapping (address => Campaign) private campaigns;\r\n\r\n  function addUser(\r\n    address _address, string memory _username, \r\n    string memory _twitter, string memory _email, \r\n    string memory _homeAddress\r\n    ) external {\r\n    emit UserAdded(_address, _username, _twitter, _email, _homeAddress);\r\n  }\r\n\r\n  function addCampaign (\r\n    string memory _title, \r\n    string memory _description,\r\n    string memory _category,\r\n    string memory _tags, \r\n    uint256 _goalAmount,\r\n    uint256 _duration,\r\n    string memory _imageURI\r\n    ) external {\r\n    Campaign newCampaign = new Campaign(\r\n      payable(msg.sender), _title, \r\n      _description, _category, \r\n      _tags, _goalAmount, \r\n      _duration, _imageURI\r\n    );\r\n    campaigns[address(newCampaign)] = newCampaign;\r\n    emit CampaignAdded(address(newCampaign), msg.sender, _title, _description, _category, _tags);\r\n  }\r\n\r\n  function donateToCampaign (address _campaignAddress) external payable {\r\n    (bool success, ) = _campaignAddress.delegatecall(abi.encodeWithSignature(\"donate()\"));\r\n    if(success){\r\n      emit CampaignFunded(msg.sender, _campaignAddress);\r\n    }else{\r\n      revert Crf_DonF();\r\n    }\r\n  }\r\n\r\n  function refundFromCampaign(address _campaignAddress, address _donator) external {\r\n    (bool success,) = _campaignAddress.delegatecall(abi.encodeWithSignature(\"refund(address)\", _donator));\r\n    if(success){\r\n      emit CampaignShrunk(msg.sender, _campaignAddress);\r\n    }else{\r\n      revert Crf_RefF();\r\n    }\r\n  }\r\n\r\n  function removeCampaign (address _campaignAddress) external {\r\n    if(campaigns[_campaignAddress].i_creator() != msg.sender){revert Crf_NotCrtr();}\r\n    if(uint(campaigns[_campaignAddress].c_state()) == 0){revert Crf_CSA();}\r\n    delete(campaigns[_campaignAddress]);\r\n    emit CampaignRemoved(_campaignAddress);\r\n  }\r\n\r\n  function publishCampaign(address _campaignAddress, address _upkeepCreator, address _linkToken) external {\r\n    (bool success, ) = _campaignAddress.delegatecall(abi.encodeWithSignature(\"timeBox(address,address,address)\", _upkeepCreator, _linkToken, _campaignAddress));\r\n    if(success){\r\n      campaignCounter = campaignCounter.add(1);\r\n      emit CampaignPublished(_campaignAddress);\r\n    }else{revert Crf_PubF();}\r\n  }\r\n\r\n  fallback() external payable{}\r\n  receive() external payable{}\r\n}"
    },
    "contracts/UpkeepIDConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\n// UpkeepIDConsumerExample.sol imports functions from both ./AutomationRegistryInterface2_0.sol and\r\n// ./interfaces/LinkTokenInterface.sol\r\n\r\nimport {AutomationRegistryInterface, State, OnchainConfig} from \"@chainlink/contracts/src/v0.8/interfaces/AutomationRegistryInterface2_0.sol\";\r\nimport {LinkTokenInterface} from \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\";\r\n\r\n/**\r\n * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.\r\n * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.\r\n * DO NOT USE THIS CODE IN PRODUCTION.\r\n */\r\n\r\ninterface KeeperRegistrarInterface {\r\n    function register(\r\n        string memory name,\r\n        bytes calldata encryptedEmail,\r\n        address upkeepContract,\r\n        uint32 gasLimit,\r\n        address adminAddress,\r\n        bytes calldata checkData,\r\n        bytes calldata offchainConfig,\r\n        uint96 amount,\r\n        address sender\r\n    ) external;\r\n}\r\n\r\ncontract UpkeepIDConsumer {\r\n    LinkTokenInterface public immutable i_link;\r\n    address public immutable registrar;\r\n    AutomationRegistryInterface public immutable i_registry;\r\n    bytes4 registerSig = KeeperRegistrarInterface.register.selector;\r\n\r\n    constructor(\r\n        LinkTokenInterface _link,\r\n        address _registrar,\r\n        AutomationRegistryInterface _registry\r\n    ) {\r\n        i_link = _link;\r\n        registrar = _registrar;\r\n        i_registry = _registry;\r\n    }\r\n\r\n    function registerAndPredictID(\r\n        string memory name,\r\n        bytes calldata encryptedEmail,\r\n        address upkeepContract,\r\n        uint32 gasLimit,\r\n        address adminAddress,\r\n        bytes calldata checkData,\r\n        bytes calldata offchainConfig,\r\n        uint96 amount\r\n    ) public returns(uint256) {\r\n        (State memory state, , , , ) = i_registry.getState();\r\n        uint256 oldNonce = state.nonce;\r\n        bytes memory payload = abi.encode(\r\n            name,\r\n            encryptedEmail,\r\n            upkeepContract,\r\n            gasLimit,\r\n            adminAddress,\r\n            checkData,\r\n            offchainConfig,\r\n            amount,\r\n            address(this)\r\n        );\r\n\r\n        i_link.transferAndCall(\r\n            registrar,\r\n            amount,\r\n            bytes.concat(registerSig, payload)\r\n        );\r\n        (state, , , , ) = i_registry.getState();\r\n        uint256 newNonce = state.nonce;\r\n        if (newNonce == oldNonce + 1) {\r\n            uint256 upkeepID = uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        blockhash(block.number - 1),\r\n                        address(i_registry),\r\n                        uint32(oldNonce)\r\n                    )\r\n                )\r\n            );\r\n            // DEV - Use the upkeepID however you see fit\r\n            return upkeepID;\r\n        } else {\r\n            revert(\"auto-approve disabled\");\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}